利用java实现
1 不需要再定义观察者和目标接口了，jdk已经定义了
2 具体的目标实现里不需要再维护观察者的注册信息了，因为在
	java中的Observable类里面已经实现了
3 处罚通知的方式有一点变化，必须先调用serChanged方法
4 具体观察者的实现里面，update方法能同时支持推和拉模型


实现的两种方式：
推模型：目标对象主动向观察者推送目标的详细信息 （按需传递）
	目标对象知道观察者需要的具体数据(难以复用)
拉模型：目标对象在通知观察者的时候，只传递少量信息（传递类名）
	目标对象不知道观察者需要什么数据，因此把自身传递给观察者，由观察者自己取值
	
	
观察者的优点
1 观察者和目标之间的抽象耦合， 但是具体的观察者和具体的目标之间实现了解耦。***
2 实现了动态联动
3 支持广播通信
观察者的缺点
1 可能会引起无谓的操作


建议在以下情况中选用观察者模式
1 当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化
2 如果在更改一个对象(目标对象)的时候，需要同时连带改变其他对象(观察者对象)，而且不知道究竟应该有多少对象需要被连带改变。
3 当一个对象必须通知其他对象，但是你有希望这个对象和其他被通知的对象是松散耦合的