synchronized的两个用法
对象锁（处理同一个实例时候，用对象锁。不能处理多个实例，因为多个实例的话，他们的锁不是同一个）
	方法锁（默认锁对象为this当前实例对象）
	同步代码块锁（自己指定锁对象）
类锁	（类锁可以处理多个对象同步的问题==>让他们拥有共同的锁 *.Class）
	静态方法锁
	Class对象锁
	
	
多线程访问同步方法的7种情况(面试常考)
	1、两个线程同时访问一个对象的同步方法   ==》	 synchronizedObjectMethod3
	2、两个线程同时访问两个对象的同步方法   ==》      	synchronized不起作用
	3、两个线程同时访问synchronized的静态方法   ==》	 	synchronizedClassStatic4
	4、同时访问同步方法与非同步方法     ==》 synchronizedYesAndNo6
	5、访问同一个对象的不同的普通同步方法    ==》   synchronizedDifferentMethod7
	6、同时访问静态	synchronized和非静态synchronized的方法    ==》 synchronizedStaticAndNormal8
	7、方法抛异常后 会释放锁
7种情况总结：3点核心思想
	1一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应第1、5种情况）
	2每个实例都对应有自己的一把锁，不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有
	对象公用一把锁（对应第2、3、4、6种情况）
	3无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应第7种情况）

synchronized性质
	1可重入性  指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁，而不是释放当前的锁去重新获取一个锁，这是它的一个优点
		* 好处：避免死锁，提升封装性

		* 粒度：是线程范围而非调用范围
		
		　　情况一：同一个方法是可以重入的
		
		　　  情况二：不同方法是可以重入的
		
		　　  情况三：不同类是可以重入的
	2不可中断
		一旦这个锁已经被别人获得了，如果我还想获得，我只能等待或者阻塞，直到别人释放这个锁，如果别人永远不释放锁，那么我只能永远等待下去，这是一个缺点

		相比之下Lock类拥有中断的能力，如果我等的时间太长了，有权中断正在执行的线程，如果不想等了，可以退出。
	
	
Java的线程生命周期有六种状态：
	New(初始化状态)
	Runnable(可运行/运行状态)
	Blocked(阻塞状态)
	Waiting(无时间限制的等待状态)
	Timed_Waiting(有时间限制的等待状态)
	Terminated(终止状态)